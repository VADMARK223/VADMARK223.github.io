{"version":3,"file":"static/js/930.46fa1be1.chunk.js","mappings":"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","sources":["../node_modules/effector-react/effector-react/createWatch.ts","../node_modules/effector-react/effector-react/apiBase.ts","../node_modules/effector-react/effector-react/scope.ts","../node_modules/effector-react/effector-react/nossr.ts","../node_modules/effector-react/effector-react/throw.ts","../node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","components/others/Effector.tsx"],"sourcesContent":["import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [step.run({fn: value => fn(value)})]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues, eventKeys, eventValues] =\n    React.useMemo(() => {\n      flagsRef.current.stale = true\n      const shape = Array.isArray(normShape) ? [] : ({} as any)\n      const storeKeys: string[] = []\n      const storeValues: Array<Store<any>> = []\n      const eventKeys: string[] = []\n      const eventValues: Array<Unit<any>> = []\n      for (const key in normShape) {\n        const unit = normShape[key]\n        if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n        if (is.event(unit) || is.effect(unit)) {\n          shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n          eventKeys.push(key)\n          eventValues.push(unit)\n        } else {\n          shape[key] = null\n          storeKeys.push(key)\n          storeValues.push(unit as Store<any>)\n        }\n      }\n      return [shape, storeKeys, storeValues, eventKeys, eventValues]\n    }, [\n      flagsRef,\n      scope,\n      ...Object.keys(normShape),\n      ...Object.values(normShape),\n    ])\n  const stateRef = React.useRef({\n    value: eventsShape,\n    storeKeys,\n    eventKeys,\n    eventValues,\n  })\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldStoreKeys = state.storeKeys\n    const oldEventKeys = state.eventKeys\n    const oldEventValues = state.eventValues\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (\n        oldStoreKeys.length !== storeKeys.length ||\n        oldEventKeys.length !== eventKeys.length\n      ) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldStoreKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n      for (let i = 0; i < eventKeys.length; i++) {\n        const updatedValue = eventValues[i]\n        const key = eventKeys[i]\n        if (!changed) {\n          if (!oldEventKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldEventValues[oldEventKeys.indexOf(key)] !== updatedValue\n          }\n        }\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    state.eventKeys = eventKeys\n    state.eventValues = eventValues\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, eventValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","/**\r\n * Компонент\r\n *\r\n * @author Markitanov Vadim\r\n * @since 30.08.2023\r\n */\r\nimport React from 'react'\r\nimport { Button, Space } from 'antd'\r\nimport { useStore, useEvent } from 'effector-react'\r\nimport { createStore, createEvent, createEffect } from 'effector'\r\nimport { unLogger } from '../../index'\r\nimport { configure } from 'effector-logger'\r\n\r\n// Events\r\nconst countStore = createStore(0, { name: 'Count store.' })\r\nconst incrementCount = createEvent('Increment count.')\r\nconst decrementCount = createEvent('Decrement count.')\r\nconst resetCountStore = createEvent('Reset count store.')\r\n\r\ncountStore\r\n  .on(incrementCount, (count) => count + 1)\r\n  .on(decrementCount, state => state - 1)\r\n  .reset(resetCountStore)\r\n\r\n// Effects\r\nconst getTags = createEffect('Get tags.')\r\ngetTags.use(async () => {\r\n  await fetch('http://localhost:60899/get_dic').then(res => {\r\n    res.json().then(value => {\r\n      console.log('Result', value)\r\n    })\r\n  })\r\n})\r\n\r\nconst fetchDicFx = createEffect('Fetch dic effect.', { handler: async (url: string) => await fetch(url).then(async req => await req.json()) })\r\nconst $dicStore = createStore(null, { name: 'Dic store.' }).on(fetchDicFx.doneData, (state, result) => result.words)\r\n\r\nconst tagsStore = createStore([], { name: 'Tags store' })\r\ntagsStore.watch(console.log)\r\n\r\nconst Effector = (): JSX.Element => {\r\n  const count = useStore(countStore)\r\n  const dic = useStore($dicStore)\r\n  const dicPending = useStore(fetchDicFx.pending)\r\n  const fetchEvent = useEvent(fetchDicFx)\r\n\r\n  return (\r\n    <Space direction={'vertical'}>\r\n      <Space>\r\n        <Button type={'primary'} onClick={() => {\r\n          incrementCount()\r\n        }}>+</Button>\r\n        <Button type={'primary'} onClick={() => {\r\n          decrementCount()\r\n        }}>-</Button>\r\n        <Button type={'primary'} onClick={() => {\r\n          resetCountStore()\r\n        }}>Reset</Button>\r\n        <span>Count: {count}</span>\r\n      </Space>\r\n      <Space>\r\n        <Button onClick={() => {\r\n          configure([incrementCount, decrementCount], { log: 'disabled' })\r\n        }}>Отписаться от логирования Unit</Button>\r\n        <Button onClick={() => {\r\n          configure([incrementCount, decrementCount], { log: 'enabled' })\r\n        }}>Подписать на логирование Unit</Button>\r\n      </Space>\r\n      <Button onClick={() => {\r\n        unLogger()\r\n      }}>Прекратить логирование</Button>\r\n      <Button onClick={() => {\r\n        getTags(null)\r\n      }}>Get tags</Button>\r\n      <Button type={'primary'} disabled={dicPending} onClick={() => {\r\n        fetchEvent('http://localhost:60899/get_dic').then(value => {\r\n          console.log('VAle', value)\r\n        })\r\n      }}>\r\n        Fetch dic\r\n      </Button>\r\n    </Space>\r\n  )\r\n}\r\n\r\nexport default Effector\r\n"],"names":["e","t","n","r","o","g","fn","unshift","k","node","graphite","id","u","additionalLinks","s","push","indexOf","splice","S","parent","family","owners","x","R","b","V","O","U","a","forceScope","Error","window","N","E","getState","Provider","countStore","createStore","name","incrementCount","createEvent","decrementCount","resetCountStore","on","count","state","reset","getTags","createEffect","use","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_context","prev","next","fetch","then","res","json","value","console","log","stop","fetchDicFx","handler","_handler","_callee3","url","_context3","_ref2","_callee2","req","_context2","abrupt","sent","_x2","apply","arguments","_x","$dicStore","doneData","result","words","watch","useStore","dicPending","pending","fetchEvent","event","j","scope","Array","isArray","concat","_toConsumableArray","Object","keys","values","useEvent","_jsxs","Space","direction","children","_jsx","Button","type","onClick","configure","unLogger","disabled"],"sourceRoot":""}